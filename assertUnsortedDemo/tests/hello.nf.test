nextflow_workflow {
    name "Test Workflow Trial"
    script "src/hello.nf"
    workflow "trial"
    test("Should run without failures") {
        when {
            workflow {
                """
                input[0] = Channel.from(["hello": ["my": "friend"]], "HYPE", "nf-test")
                """
            }
        }
        then {
            assert workflow.success
            // assert workflow.out.trial_out_ch == ["hello", "nf-test", "HYPE"]
            // assert workflow.out.trial_out_ch[3] == "hello"

            println "workflow.out.trial_out_ch"
            println workflow.out.trial_out_ch

            // assertListUnsorted(workflow.out.trial_out_ch, ["hello", "nf-test", "HYPE"])

            def myMap = [:]
            def anotherMap = [:]
            def channel = []
            def expected = []
            def jsonPath = '/home/a.fishman/repos/nf-test/test-data/process/path-util/input.json'

            myMap = [
                'A': [1,2,3],
                'B': [4,5,6]
            ]

            // Single Map
            channel = [myMap]

            expected = [
                [
                    'A': [1,2,3],
                    'B': [4,5,6]
                ]
            ]

            assertChannel(channel, expected)

            // Out of order maps
            anotherMap = [
                'C': [6,6,6],
                'D': [9,9,9]
            ]

            channel = [myMap, anotherMap]
            expected = [anotherMap, myMap]

            assertChannel(channel, expected)

            // Json
            channel = [jsonPath]

            expected = [path(jsonPath).json]
            assertChannel(channel, expected)

            // Map/Json Tuples
            channel = [[myMap, jsonPath]]
            expected = [[myMap, path(jsonPath).json]]

            assertChannel(channel, expected)

            // Out of order Map/Json Tuples
            channel = [[myMap, jsonPath], [anotherMap, jsonPath]]
            expected = [[anotherMap, path(jsonPath).json], [myMap, path(jsonPath).json]]

            assertChannel(channel, expected)

            // A Subset of items
            channel = [[myMap, jsonPath], [anotherMap, jsonPath]]
            expected = [[anotherMap, path(jsonPath).json], [myMap, path(jsonPath).json]]

            assertChannel(channel, expected) 

            // Multiple Items



            /* Earlier that day.... */

            // def a = [
            //     'A': [1,2,3],
            //     'B': [1,2,3]
            // ]

            // def b = [
            //     'B': [1,2,3],
            //     'A': [1,2,4]
            // ]

            // def c = [
            //     'A': [1,2,3],
            //     'B': [1,2,4]
            // ]

            // try{
            //     assert 1==2
            // }
            // catch(Throwable thrown) {
            //     println "Groovy Type"
            //     println thrown.getClass()
            // }

            // assertListUnsorted([a, b, b, a], [a, a, a, b])

            // assertListUnsorted(workflow.out.trial_out_ch, [])

            // assertAll(
            //     { assertListUnsortedWithPaths(['/hello/path.txt', '/hello/path.txt'], ['/another/path.txt']) },
            //     { assertListUnsortedWithPaths(workflow.out.trial_out_ch, ["HYPE", ["hello": ["my": "friend"]], "nf-test" ]) }
            // )
            
            // assertListUnsortedWithPaths(workflow.out.trial_out_ch, ["HYPEE", ["hello": ["my": "friend"]], "nf-test" ])
            // assertListUnsortedWithPaths(workflow.out.trial_out_ch, ["HYPEE", ["hello": ["my": "friend"]], "nf-test" ])

            // println ""

            // assertListUnsorted(['path'], ['path'])
        }
    }
}